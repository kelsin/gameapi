# Game API

[![license](https://img.shields.io/github/license/kelsin/gameapi?logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBzdHJva2U9Im5vbmUiIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz48cGF0aCBkPSJNNyAyMGwxMCAwIi8%2BPHBhdGggZD0iTTYgNmw2IC0xbDYgMSIvPjxwYXRoIGQ9Ik0xMiAzbDAgMTciLz48cGF0aCBkPSJNOSAxMmwtMyAtNmwtMyA2YTMgMyAwIDAgMCA2IDAiLz48cGF0aCBkPSJNMjEgMTJsLTMgLTZsLTMgNmEzIDMgMCAwIDAgNiAwIi8%2BPC9zdmc%2B&logoColor=%23fff&color=%23750014)](https://github.com/kelsin/gameapi?tab=MIT-1-ov-file#readme)

A Game-Agnostic Web API for Turn Based Games.

## Definition

This repo is meant to define and contain a reference implementation of an API
for turn based game development.

The API supports HTTP REST requests with SSE for realtime events, and
Websockets. Each method uses the same JSON messages and schemas for
communication.

## Example Session

Imagine we have a game of
[Root](https://ledergames.com/products/root-a-game-of-woodland-might-and-right)
with 3 players. We'll name them Ada [^1], Betty [^2], and Carol [^3]. They are
in the middle of a game. This section is meant to explain how the game api works
with examples of what messages might look like.

> [!NOTE]
> This example was written prior to the full API spec being designed. Messages
> and their schemas are not final.

[^1]: [Ada Lovelace](https://en.wikipedia.org/wiki/Ada_Lovelace) was the
    designer of the first algorithm.
[^2]: [Betty Holberton](https://en.wikipedia.org/wiki/Betty_Holberton) invented
    breakpoints in compute debugging and was one of the six original programmers
    of ENIAC.
[^3]: [Carol Shaw](https://en.wikipedia.org/wiki/Carol_Shaw) was one of the
    first female video game designers.

### Game Meta Data

> [!TIP]
> In the Game API all ids are
> [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random))
> values. In this document we will just use strings like `<game_id>` and
> `<player_ada_id>` instead of full UUIDs for readability.

The metadata for a game can be retrieved at `/games/<game_id>`. This will return
something like:

``` json
{
  "game": {
    "id": "<game_id>",
    "created_at": "2023-06-13T09:41:00+00:00",
    "current_turn": 100,
    "current_action": "<action_100_id>",
    "current_player": "<player_ada_id>",
    "players": [{
      "name": "Ada",
      "id": "<player_ada_id>",
      "index": 0,
      "faction": "cat",
      "color": "orange",
    },{
      "name": "Betty",
      "id": "<player_betty_id>",
      "index": 1,
      "faction": "eyrie",
      "color": "blue",
    },{
      "name": "Carol",
      "id": "<player_carol_id>",
      "index": 2,
      "faction": "woodland",
      "color": "green",
    }],
  }
}
```

In this example all root fields in the `game` object are required and managed by
the API itself. In the player objects only `id` is required. `index` is created
by the API (a random player ordering that can be used by the games if
needed). `name` is optional and most clients should set it. Fields like
`faction` and `color` are just created by the game client for their game. A lot
of objects in the Game API support any extra fields on objects to support game
features.

### State

You can get the full current game state with `/games/<game_id>/states/current`
or the initial game state with `/games/<game_id>/states/initial`.

``` json
{
  "game": "<game_id>",
  "state": {
    "scores": {
      "<player_ada_id>": 13,
      "<player_betty_id>": 13,
      "<player_carol_id>": 13
    }
  },
  "turn": 100,
  "action": "<action_100_id>",
  "parent": "<action_99_id>",
  "siblings": ["<action_100.1_id>", "<action_100.2_id>"],
  "children": ["<action_101_id>"],
  "player": "<player_betty_id>",
}
```

The `state` field is fully game dependent and supports all valid JSON. The other
fields are all generated by the API.

### Actions

You can get actions at `/games/<game_id>/actions`. This result is paginated and
defaults to recent events first.

You can get information about a single action at
`/games/<game_id>/actions/<action_id>`:

``` json
{
  "game": "<game_id>",
  "id": "<action_100_id>",
  "action": {
    "type": "MOVE",
    "from": "clearing_1",
    "to": "clearing_2",
    "warriors": 3,
  },
  "player": "<player_betty_id>",
  "parent": "<action_99_id>",
  "siblings": ["<action_100.1_id>", "<action_100.2_id>"],
  "children": ["<action_101_id>"],
  "log": "Human readable string of what happened",
  "created_at": "2024-06-13T09:41:00+00:00",
}
```

Just like the `state` field in the state APIs the `action` field here is fully
game dependent. All other fields in this example are generated by the API except
`log` which is a required part of creating an action (we'll see that later).
